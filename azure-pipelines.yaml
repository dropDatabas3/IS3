# Azure DevOps Pipeline CI – IS3
# Frontend: Next.js 14.2.3  | Backend: Go 1.22.6
# Pool: Self-hosted (TP4_IS3) — SIN Cache@2

trigger:
  branches:
    include: [ main ]
  paths:
    exclude:
      - README.md
      - decisiones.md
      - '*.md'

pr:
  branches:
    include: [ main ]
  paths:
    exclude:
      - README.md
      - decisiones.md
      - '*.md'

variables:
  agentPool: 'TP4_IS3'
  nodeVersion: '20.12.0'      # compatible con Next 14.2.3
  goVersion: '1.22.6'         # cumple con go 1.22 de tu go.mod
  frontendPath: 'ucc-arq-soft-front'
  backendPath: 'ucc-soft-arch-golang'
  majorVersion: 1
  minorVersion: 0
  patchVersion: $[counter(variables['Build.SourceBranchName'], 0)]
  buildVersion: '$(majorVersion).$(minorVersion).$(patchVersion)'

  # === TP05/TP08: ACR + Deploy backend (Go) a Web Apps Linux (Containers) ===
  # Conexiones y ACR
  azureSubscription: 'azure-tp05-connection'          # Service connection Azure RM (ya creada)
  dockerRegistryServiceConnection: 'acr-connection'   # Service connection a tu ACR
  acrLoginServer: 'acrpalacionallar.azurecr.io'       # Login server real de tu ACR

  # Imagen backend y tag inmutable (build once → deploy many)
  backendImageName: 'is3-backend'
  imageTag: '$(Build.BuildId)'

  # Web Apps Linux (containers) – Opción A
  backendAppQA:   'backend-tp05-qa-palacio-nallar'
  backendAppProd: 'backend-tp05-prod-palacio-nallar'
  backendUrlQA:   'https://backend-tp05-qa-palacio-nallar.azurewebsites.net'
  backendUrlProd: 'https://backend-tp05-prod-palacio-nallar.azurewebsites.net'

stages:
- stage: CI
  displayName: 'Continuous Integration'
  jobs:

  # =========================
  # FRONTEND (Next.js / Node)
  # =========================
  - job: BuildFrontend
    displayName: 'Build Frontend (Next.js)'
    pool: { name: $(agentPool) }
    steps:
    - checkout: self
      clean: true
      displayName: 'Checkout Source Code'

    - task: NodeTool@0
      displayName: 'Use Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'
        checkLatest: false

    - script: |
        cd $(frontendPath)
        echo Installing frontend dependencies...
        if exist package-lock.json ( npm ci --prefer-offline --no-audit --no-fund ) else ( npm i --no-audit --no-fund )
      displayName: 'Install Frontend Dependencies'

    - script: |
        cd $(frontendPath)
        npm run lint
      displayName: 'Run Frontend Linting'
      continueOnError: true

    - script: |
        cd $(frontendPath)
        npm run build
      displayName: 'Build Frontend Application'
      env:
        NEXT_PUBLIC_API_URL: 'http://localhost:8000'
        NEXT_TELEMETRY_DISABLED: '1'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend Build (.next)'
      inputs:
        PathtoPublish: '$(frontendPath)/.next'
        ArtifactName: 'frontend-dist'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend package.json'
      inputs:
        PathtoPublish: '$(frontendPath)/package.json'
        ArtifactName: 'frontend-config'
        publishLocation: 'Container'

  # =================
  # BACKEND (Go 1.22)
  # =================
  - job: BuildBackend
    displayName: 'Build Backend (Go)'
    pool: { name: $(agentPool) }
    dependsOn: BuildFrontend
    steps:
    - checkout: self
      clean: true
      displayName: 'Checkout Source Code'

    - task: GoTool@0
      displayName: 'Use Go $(goVersion)'
      inputs:
        version: '$(goVersion)'

    - script: |
        cd $(backendPath)
        go version
        echo Descargar dependencias...
        go mod download
        go mod verify
      displayName: 'Download Backend Dependencies'

    - script: |
        cd $(backendPath)
        echo Analisis estático (go vet)...
        go vet ./...
      displayName: 'Run Go Vet (Static Analysis)'
      continueOnError: true

    - script: |
        cd $(backendPath)
        echo Formato (go fmt)...
        go fmt ./...
      displayName: 'Check Go Formatting'
      continueOnError: true

    # Build nativo en Windows → genera bin\app.exe
    - script: |
        cd $(backendPath)
        if not exist bin mkdir bin
        echo Compilando backend...
        go build -ldflags="-w -s" -o .\bin\app.exe .\main.go
        dir .\bin
      displayName: 'Build Backend Binary (Windows)'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend Binary'
      inputs:
        PathtoPublish: '$(backendPath)/bin'
        ArtifactName: 'backend-bin'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend go.mod'
      inputs:
        PathtoPublish: '$(backendPath)/go.mod'
        ArtifactName: 'backend-config'
        publishLocation: 'Container'

  # ============================
  # Resumen (opcional)
  # ============================
  - job: PublishSummary
    displayName: 'Build Summary'
    pool: { name: $(agentPool) }
    dependsOn:
      - BuildFrontend
      - BuildBackend
    steps:
    - script: |
        echo ======================================
        echo    CI BUILD COMPLETED SUCCESSFULLY
        echo ======================================
        echo Build Version: $(buildVersion)
        echo Frontend: Next.js build completed
        echo Backend: Go binary compiled
        echo Artifacts:
        echo  - frontend-dist (.next)
        echo  - frontend-config (package.json)
        echo  - backend-bin (app.exe)
        echo  - backend-config (go.mod)
      displayName: 'Display Build Summary'

# ======================================================
# TP08: Build & Push backend (Go) → ACR
# TP05: Deploy QA → aprobación → Deploy PROD (Web Apps Linux containers)
# ======================================================

- stage: BuildAndPushBackend
  displayName: 'TP08: Build & Push Backend to ACR'
  dependsOn: CI
  condition: succeeded()
  jobs:
  - job: BuildPush
    displayName: 'Docker build/push (backend)'
    pool: { name: $(agentPool) }
    steps:
      - checkout: self
        clean: true

      - task: Docker@2
        displayName: 'Login to ACR'
        inputs:
          command: 'login'
          containerRegistry: '$(dockerRegistryServiceConnection)'

      - task: Docker@2
        displayName: 'Build & Push Backend'
        inputs:
          command: 'buildAndPush'
          repository: '$(acrLoginServer)/$(backendImageName)'
          Dockerfile: '$(backendPath)/Dockerfile'
          buildContext: '$(backendPath)'
          tags: |
            $(imageTag)

- stage: Deploy_QA
  displayName: 'TP05: Deploy Backend to QA'
  dependsOn: BuildAndPushBackend
  condition: succeeded()
  jobs:
  - deployment: DeployBackendQA
    displayName: 'Deploy Backend (QA)'
    pool: { name: $(agentPool) }
    environment: 'QA'   # Environment QA en Azure DevOps (sin aprobación)
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureWebApp@1
              displayName: 'Deploy Backend QA (container)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                appName: '$(backendAppQA)'
                appType: 'webAppLinux'
                runtimeStack: ''
                imageName: '$(acrLoginServer)/$(backendImageName):$(imageTag)'
                appSettings: >
                  -PORT 8000
                  -ENV qa
                  -DATABASE_URL $(DATABASE_URL_QA)

            - task: PowerShell@2
              displayName: 'Health Check QA (/health)'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = 'Stop'
                  Write-Host "Esperando 20s a que arranque..."; Start-Sleep -Seconds 20
                  $resp = Invoke-WebRequest -Uri "$(backendUrlQA)/health" -UseBasicParsing
                  if ($resp.StatusCode -ne 200) { throw "Health check FAILED: $($resp.StatusCode)" }

- stage: Deploy_PROD
  displayName: 'TP05: Deploy Backend to PROD (Approval)'
  dependsOn: Deploy_QA
  condition: succeeded()
  jobs:
  - deployment: DeployBackendProd
    displayName: 'Deploy Backend (PROD)'
    pool: { name: $(agentPool) }
    environment: 'PROD'  # Configurar aprobación manual en Environment PROD
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureWebApp@1
              displayName: 'Deploy Backend PROD (container)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                appName: '$(backendAppProd)'
                appType: 'webAppLinux'
                runtimeStack: ''
                imageName: '$(acrLoginServer)/$(backendImageName):$(imageTag)'
                appSettings: >
                  -PORT 8000
                  -ENV production
                  -DATABASE_URL $(DATABASE_URL_PROD)

            - task: PowerShell@2
              displayName: 'Health Check PROD (/health)'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = 'Stop'
                  Write-Host "Esperando 20s a que arranque..."; Start-Sleep -Seconds 20
                  $resp = Invoke-WebRequest -Uri "$(backendUrlProd)/health" -UseBasicParsing
                  if ($resp.StatusCode -ne 200) { throw "Health check FAILED: $($resp.StatusCode)" }
