# Azure DevOps Pipeline CI – IS3
# Frontend: Next.js 14.2.3  | Backend: Go 1.22.6
# Pool: Self-hosted (TP4_IS3) — SIN Cache@2

trigger:
  branches:
    include: [ main ]
  paths:
    exclude:
      - README.md
      - decisiones.md
      - '*.md'

pr:
  branches:
    include: [ main ]
  paths:
    exclude:
      - README.md
      - decisiones.md
      - '*.md'

variables:
  agentPool: 'TP4_IS3'
  nodeVersion: '20.18.0'      # actualizado para compatibilidad con dependencias de Jest/msw
  goVersion: '1.22.6'         # cumple con go 1.22 de tu go.mod
  frontendPath: 'ucc-arq-soft-front'
  backendPath: 'ucc-soft-arch-golang'
  majorVersion: 1
  minorVersion: 0
  patchVersion: $[counter(variables['Build.SourceBranchName'], 0)]
  buildVersion: '$(majorVersion).$(minorVersion).$(patchVersion)'

  # === TP05/TP08: ACR + Deploy backend (Go) a Web Apps Linux (Containers) ===
  # Conexiones y ACR
  azureSubscription: 'azure-tp05-connection'          # Service connection Azure RM (ya creada)
  dockerRegistryServiceConnection: 'acr-connection'   # Service connection a tu ACR
  acrLoginServer: 'acrpalacionallar.azurecr.io'       # Login server real de tu ACR

  # Imagen backend y tag inmutable (build once → deploy many)
  backendImageName: 'is3-backend'
  imageTag: '$(Build.BuildId)'

  # Web Apps Linux (containers) – Opción A
  backendAppQA:   'backend-tp05-qa-palacio-nallar'
  backendAppProd: 'backend-tp05-prod-palacio-nallar'
  backendUrlQA:   'https://backend-tp05-qa-palacio-nallar.azurewebsites.net'
  backendUrlProd: 'https://backend-tp05-prod-palacio-nallar.azurewebsites.net'

  # FRONTEND (opcional): imagen y Web Apps
  frontendImageName: 'is3-frontend'
  # Completar con las Web Apps creadas para Front
  frontendAppQA: 'front-tp05-qa-palacio-nallar'
  frontendAppProd: 'front-tp05-prod-palacio-nallar'
  frontendUrlQA: ''
  frontendUrlProd: ''

stages:
- stage: CI
  displayName: 'Continuous Integration'
  jobs:

  # =========================
  # FRONTEND (Next.js / Node)
  # =========================
  - job: BuildFrontend
    displayName: 'Build Frontend (Next.js)'
    pool: { name: $(agentPool) }
    steps:
    - checkout: self
      clean: true
      displayName: 'Checkout Source Code'

    - task: NodeTool@0
      displayName: 'Use Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'
        checkLatest: false

    - script: |
        cd $(frontendPath)
        echo Installing frontend dependencies...
        if exist package-lock.json ( npm ci --prefer-offline --no-audit --no-fund ) else ( npm i --no-audit --no-fund )
      displayName: 'Install Frontend Dependencies'

    - script: |
        cd $(frontendPath)
        npm run lint
      displayName: 'Run Frontend Linting'
      continueOnError: true

    - task: PowerShell@2
      displayName: 'Run Frontend Unit Tests (Jest → JUnit + Cobertura)'
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'
          cd "$(frontendPath)"
          # Asegurar reporter JUnit disponible sin modificar package.json
          npm i --no-save jest-junit
          # Configurar salida JUnit y generar Cobertura + LCov
          $env:CI = 'true'
          $env:JEST_JUNIT_OUTPUT = "$(frontendPath)\test-results\junit.xml"
          if (-not (Test-Path "$(frontendPath)\test-results")) { New-Item -ItemType Directory -Path "$(frontendPath)\test-results" | Out-Null }
          # Ejecutar jest con reportes
          npx jest --ci --reporters=default --reporters=jest-junit --coverage --coverageReporters=cobertura --coverageReporters=lcov

    - task: PublishTestResults@2
      displayName: 'Publish Frontend Test Results (JUnit)'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(frontendPath)/test-results/junit.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)'
        testRunTitle: 'Frontend Tests'
        failTaskOnFailedTests: true

    - task: PowerShell@2
      displayName: 'Normalize Frontend Cobertura paths (avoid spaces issues)'
      condition: succeededOrFailed()
      inputs:
        targetType: 'inline'
        script: |
          $file = "$(frontendPath)\coverage\cobertura-coverage.xml"
          if (Test-Path $file) {
            $content = Get-Content -Raw -Path $file
            $root = "$(System.DefaultWorkingDirectory)"
            $pattern = [Regex]::Escape($root)
            $content = [Regex]::Replace($content, $pattern, ".")
            $rootFwd = $root -replace '\\','/'
            $patternFwd = [Regex]::Escape($rootFwd)
            $content = [Regex]::Replace($content, $patternFwd, ".")
            Set-Content -Path $file -Value $content -NoNewline
          }

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Frontend Coverage (Cobertura)'
      condition: succeededOrFailed()
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(frontendPath)/coverage/cobertura-coverage.xml'
        reportDirectory: '$(frontendPath)/coverage'
        failIfCoverageEmpty: false

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend Coverage'
      condition: succeededOrFailed()
      inputs:
        PathtoPublish: '$(frontendPath)/coverage'
        ArtifactName: 'frontend-coverage'
        publishLocation: 'Container'

    - script: |
        cd $(frontendPath)
        npm run build
      displayName: 'Build Frontend Application'
      env:
        NEXT_PUBLIC_API_URL: 'http://localhost:8000'
        NEXT_TELEMETRY_DISABLED: '1'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend Build (.next)'
      inputs:
        PathtoPublish: '$(frontendPath)/.next'
        ArtifactName: 'frontend-dist'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend package.json'
      inputs:
        PathtoPublish: '$(frontendPath)/package.json'
        ArtifactName: 'frontend-config'
        publishLocation: 'Container'

  # =================
  # BACKEND (Go 1.22)
  # =================
  - job: BuildBackend
    displayName: 'Build Backend (Go)'
    pool: { name: $(agentPool) }
    dependsOn: BuildFrontend
    steps:
    - checkout: self
      clean: true
      displayName: 'Checkout Source Code'

    - task: GoTool@0
      displayName: 'Use Go $(goVersion)'
      inputs:
        version: '$(goVersion)'

    - script: |
        cd $(backendPath)
        go version
        echo Descargar dependencias...
        go mod download
        go mod verify
      displayName: 'Download Backend Dependencies'

    - script: |
        cd $(backendPath)
        echo Analisis estático (go vet)...
        go vet ./...
      displayName: 'Run Go Vet (Static Analysis)'
      continueOnError: true

    - task: PowerShell@2
      displayName: 'Run Backend Unit Tests (Go → JUnit + Cobertura)'
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'
          cd "$(backendPath)"
          # Instalar herramientas para reportes JUnit y Cobertura
          go install github.com/jstemmer/go-junit-report/v2@latest
          go install github.com/boumenot/gocover-cobertura@latest
          $gopath = (go env GOPATH)
          $junitExe = Join-Path $gopath 'bin\go-junit-report.exe'
          $cobExe = Join-Path $gopath 'bin\gocover-cobertura.exe'
          # Ejecutar tests con cobertura y convertir a JUnit
          if (-not (Test-Path "$(backendPath)\test-results")) { New-Item -ItemType Directory -Path "$(backendPath)\test-results" | Out-Null }
          # Ejecuta tests y canaliza a junit (con exit code correcto)
          powershell -NoLogo -NoProfile -Command "cd $(backendPath); go test ./... -v -coverprofile=coverage.out 2>&1 | & '$junitExe' -set-exit-code > junit-report.xml"
          if ($LASTEXITCODE -ne 0) { throw "Unit tests failed" }
          # Convertir coverage.out a Cobertura
          & $cobExe -i coverage.out -o coverage.cobertura.xml

    - task: PublishTestResults@2
      displayName: 'Publish Backend Test Results (JUnit)'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(backendPath)/junit-report.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)'
        testRunTitle: 'Backend Tests'
        failTaskOnFailedTests: true

    - task: PowerShell@2
      displayName: 'Normalize Backend Cobertura paths (avoid spaces issues)'
      condition: succeededOrFailed()
      inputs:
        targetType: 'inline'
        script: |
          $file = "$(backendPath)\coverage.cobertura.xml"
          if (Test-Path $file) {
            $content = Get-Content -Raw -Path $file
            $root = "$(System.DefaultWorkingDirectory)"
            $pattern = [Regex]::Escape($root)
            $content = [Regex]::Replace($content, $pattern, ".")
            $rootFwd = $root -replace '\\','/'
            $patternFwd = [Regex]::Escape($rootFwd)
            $content = [Regex]::Replace($content, $patternFwd, ".")
            Set-Content -Path $file -Value $content -NoNewline
          }

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Backend Coverage (Cobertura)'
      condition: succeededOrFailed()
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(backendPath)/coverage.cobertura.xml'
        reportDirectory: '$(backendPath)'
        failIfCoverageEmpty: false

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend Coverage'
      condition: succeededOrFailed()
      inputs:
        PathtoPublish: '$(backendPath)/coverage.out'
        ArtifactName: 'backend-coverage'
        publishLocation: 'Container'

    - script: |
        cd $(backendPath)
        echo Formato (go fmt)...
        go fmt ./...
      displayName: 'Check Go Formatting'
      continueOnError: true

    # Build nativo en Windows → genera bin\app.exe
    - script: |
        cd $(backendPath)
        if not exist bin mkdir bin
        echo Compilando backend...
        go build -ldflags="-w -s" -o .\bin\app.exe .\main.go
        dir .\bin
      displayName: 'Build Backend Binary (Windows)'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend Binary'
      inputs:
        PathtoPublish: '$(backendPath)/bin'
        ArtifactName: 'backend-bin'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend go.mod'
      inputs:
        PathtoPublish: '$(backendPath)/go.mod'
        ArtifactName: 'backend-config'
        publishLocation: 'Container'

  # ============================
  # Resumen (opcional)
  # ============================
  - job: PublishSummary
    displayName: 'Build Summary'
    pool: { name: $(agentPool) }
    dependsOn:
      - BuildFrontend
      - BuildBackend
    steps:
    - script: |
        echo ======================================
        echo    CI BUILD COMPLETED SUCCESSFULLY
        echo ======================================
        echo Build Version: $(buildVersion)
        echo Frontend: Next.js build completed
        echo Backend: Go binary compiled
        echo Artifacts:
        echo  - frontend-dist (.next)
        echo  - frontend-config (package.json)
        echo  - backend-bin (app.exe)
        echo  - backend-config (go.mod)
      displayName: 'Display Build Summary'

# ======================================================
# TP08: Build & Push backend (Go) → ACR
# TP05: Deploy QA → aprobación → Deploy PROD (Web Apps Linux containers)
# ======================================================

- stage: BuildAndPushImages
  displayName: 'TP08: Build & Push Backend to ACR'
  dependsOn: CI
  condition: succeeded()
  jobs:
  - job: BuildPush
    displayName: 'Docker build/push (backend + frontend)'
    pool: { name: $(agentPool) }
    steps:
      - checkout: self
        clean: true

      - task: Docker@2
        displayName: 'Login to ACR'
        inputs:
          command: 'login'
          containerRegistry: '$(dockerRegistryServiceConnection)'

      - task: Docker@2
        displayName: 'Build & Push Backend'
        inputs:
          command: 'buildAndPush'
          repository: '$(acrLoginServer)/$(backendImageName)'
          Dockerfile: '$(backendPath)/Dockerfile'
          buildContext: '$(backendPath)'
          tags: |
            $(imageTag)

      - task: Docker@2
        displayName: 'Build & Push Frontend'
        inputs:
          command: 'buildAndPush'
          repository: '$(acrLoginServer)/$(frontendImageName)'
          Dockerfile: '$(frontendPath)/Dockerfile'
          buildContext: '$(frontendPath)'
          tags: |
            $(imageTag)

- stage: Deploy_QA
  displayName: 'TP05: Deploy Backend to QA'
  dependsOn: BuildAndPushImages
  condition: succeeded()
  jobs:
  - deployment: DeployBackendQA
    displayName: 'Deploy Backend (QA)'
    pool: { name: $(agentPool) }
    environment: 'QA'   # Environment QA en Azure DevOps (sin aprobación)
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureWebApp@1
              displayName: 'Deploy Backend QA (container)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                appName: '$(backendAppQA)'
                appType: 'webAppLinux'
                runtimeStack: ''
                imageName: '$(acrLoginServer)/$(backendImageName):$(imageTag)'
                appSettings: >
                  -PORT 8000
                  -WEBSITES_PORT 8000
                  -ENV qa
                  -DATABASE_URL $(DATABASE_URL_QA)

            - task: PowerShell@2
              displayName: 'Health Check QA (/health)'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = 'Stop'
                  Write-Host "Esperando 20s a que arranque..."; Start-Sleep -Seconds 20
                  $resp = Invoke-WebRequest -Uri "$(backendUrlQA)/health" -UseBasicParsing
                  if ($resp.StatusCode -ne 200) { throw "Health check FAILED: $($resp.StatusCode)" }

  - deployment: DeployFrontendQA
    displayName: 'Deploy Frontend (QA)'
    pool: { name: $(agentPool) }
    dependsOn: DeployBackendQA
    condition: and(succeeded(), ne(variables['frontendAppQA'], ''))
    environment: 'QA'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureWebApp@1
              displayName: 'Deploy Frontend QA (container)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                appName: '$(frontendAppQA)'
                appType: 'webAppLinux'
                runtimeStack: ''
                imageName: '$(acrLoginServer)/$(frontendImageName):$(imageTag)'
                appSettings: >
                  -PORT 3000
                  -WEBSITES_PORT 3000
                  -NEXT_PUBLIC_API_URL https://$(backendAppQA).azurewebsites.net

- stage: Deploy_PROD
  displayName: 'TP05: Deploy Backend to PROD (Approval)'
  dependsOn: Deploy_QA
  condition: succeeded()
  jobs:
  - deployment: DeployBackendProd
    displayName: 'Deploy Backend (PROD)'
    pool: { name: $(agentPool) }
    environment: 'PROD'  # Configurar aprobación manual en Environment PROD
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureWebApp@1
              displayName: 'Deploy Backend PROD (container)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                appName: '$(backendAppProd)'
                appType: 'webAppLinux'
                runtimeStack: ''
                imageName: '$(acrLoginServer)/$(backendImageName):$(imageTag)'
                appSettings: >
                  -PORT 8000
                  -WEBSITES_PORT 8000
                  -ENV production
                  -DATABASE_URL $(DATABASE_URL_PROD)

            - task: PowerShell@2
              displayName: 'Health Check PROD (/health)'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = 'Stop'
                  Write-Host "Esperando 20s a que arranque..."; Start-Sleep -Seconds 20
                  $resp = Invoke-WebRequest -Uri "$(backendUrlProd)/health" -UseBasicParsing
                  if ($resp.StatusCode -ne 200) { throw "Health check FAILED: $($resp.StatusCode)" }

  - deployment: DeployFrontendProd
    displayName: 'Deploy Frontend (PROD)'
    pool: { name: $(agentPool) }
    dependsOn: DeployBackendProd
    condition: and(succeeded(), ne(variables['frontendAppProd'], ''))
    environment: 'PROD'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureWebApp@1
              displayName: 'Deploy Frontend PROD (container)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                appName: '$(frontendAppProd)'
                appType: 'webAppLinux'
                runtimeStack: ''
                imageName: '$(acrLoginServer)/$(frontendImageName):$(imageTag)'
                appSettings: >
                  -PORT 3000
                  -WEBSITES_PORT 3000
                  -NEXT_PUBLIC_API_URL https://$(backendAppProd).azurewebsites.net
