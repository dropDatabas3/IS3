# Azure DevOps Pipeline CI – IS3
# Frontend: Next.js 14.2.3  | Backend: Go 1.22.6
# Pool: Self-hosted (TP4_IS3) — SIN Cache@2

trigger:
  branches:
    include: [ main ]
  paths:
    exclude:
      - README.md
      - decisiones.md
      - '*.md'

pr:
  branches:
    include: [ main ]
  paths:
    exclude:
      - README.md
      - decisiones.md
      - '*.md'

variables:
  agentPool: 'TP4_IS3'
  nodeVersion: '20.18.0'      # actualizado para compatibilidad con dependencias de Jest/msw
  goVersion: '1.22.6'         # cumple con go 1.22 de tu go.mod
  frontendPath: 'ucc-arq-soft-front'
  backendPath: 'ucc-soft-arch-golang'
  majorVersion: 1
  minorVersion: 0
  patchVersion: $[counter(variables['Build.SourceBranchName'], 0)]
  buildVersion: '$(majorVersion).$(minorVersion).$(patchVersion)'

  # === TP05/TP08: ACR + Deploy backend (Go) a Web Apps Linux (Containers) ===
  # Conexiones y ACR
  azureSubscription: 'azure-tp05-connection'          # Service connection Azure RM (ya creada)
  dockerRegistryServiceConnection: 'acr-connection'   # Service connection a tu ACR
  acrLoginServer: 'acrpalacionallar.azurecr.io'       # Login server real de tu ACR

  # Imagen backend y tag inmutable (build once → deploy many)
  backendImageName: 'is3-backend'
  imageTag: '$(Build.BuildId)'

  # Web Apps Linux (containers)
  backendAppQA:   'backend-tp05-qa-palacio-nallar'
  backendAppProd: 'backend-tp05-prod-palacio-nallar'
  backendUrlQA:   'https://backend-tp05-qa-palacio-nallar.azurewebsites.net'
  backendUrlProd: 'https://backend-tp05-prod-palacio-nallar.azurewebsites.net'

  # FRONTEND: imagen y Web Apps
  frontendImageName: 'is3-frontend'
  frontendAppQA: 'front-tp05-qa-palacio-nallar'
  frontendAppProd: 'front-tp05-prod-palacio-nallar'
  frontendUrlQA: ''
  frontendUrlProd: ''

  # Credenciales ACR (usuario fijo + password desde variable secreta)
  acrUser: 'acrPalacioNallar'
  acrPassword: '$(ACR_PASSWORD)'    # ACR_PASSWORD = secreto en Azure DevOps

stages:
- stage: CI
  displayName: 'Continuous Integration'
  jobs:

  # =========================
  # FRONTEND (Next.js / Node)
  # =========================
  - job: BuildFrontend
    displayName: 'Build Frontend (Next.js)'
    pool: { name: $(agentPool) }
    steps:
    - checkout: self
      clean: true
      displayName: 'Checkout Source Code'

    - task: NodeTool@0
      displayName: 'Use Node.js $(nodeVersion)'
      inputs:
        versionSpec: '$(nodeVersion)'
        checkLatest: false

    - script: |
        cd $(frontendPath)
        echo Installing frontend dependencies...
        if exist package-lock.json ( npm ci --prefer-offline --no-audit --no-fund ) else ( npm i --no-audit --no-fund )
      displayName: 'Install Frontend Dependencies'

    - script: |
        cd $(frontendPath)
        npm run lint
      displayName: 'Run Frontend Linting'
      continueOnError: true

    - task: PowerShell@2
      displayName: 'Run Frontend Unit Tests (Jest → JUnit + Cobertura)'
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'

          $frontendRoot = Join-Path "$(System.DefaultWorkingDirectory)" "$(frontendPath)"
          Write-Host "Frontend root: $frontendRoot"

          cd $frontendRoot

          # Asegurar reporter JUnit disponible sin modificar package.json
          npm i --no-save jest-junit

          # Configurar salida JUnit y generar Cobertura + LCov
          $testResultsDir = Join-Path $frontendRoot "test-results"
          if (-not (Test-Path $testResultsDir)) {
            New-Item -ItemType Directory -Path $testResultsDir | Out-Null
          }

          $env:CI = 'true'

          # Configuración primaria: variable única de salida (formatos antiguos de jest-junit)
          $junitFile = Join-Path $testResultsDir "junit.xml"
          $env:JEST_JUNIT_OUTPUT = $junitFile

          # Configuración alternativa: OUTPUT_DIR + OUTPUT_NAME (formatos más nuevos)
          $env:JEST_JUNIT_OUTPUT_DIR = $testResultsDir
          $env:JEST_JUNIT_OUTPUT_NAME = "junit.xml"

          Write-Host "[Jest-JUnit] OUTPUT          = $($env:JEST_JUNIT_OUTPUT)"
          Write-Host "[Jest-JUnit] OUTPUT_DIR      = $($env:JEST_JUNIT_OUTPUT_DIR)"
          Write-Host "[Jest-JUnit] OUTPUT_NAME     = $($env:JEST_JUNIT_OUTPUT_NAME)"

          # Ejecutar jest con reportes
          Write-Host "Running Jest with JUnit + coverage reporters..."
          npx jest --ci --reporters=default --reporters=jest-junit --coverage --coverageReporters=cobertura --coverageReporters=lcov

          # Log detallado sobre la generación (sin romper el build)
          if (Test-Path $junitFile) {
            $size = (Get-Item $junitFile).Length
            Write-Host "[Jest-JUnit] Report generated at: $junitFile (size: $size bytes)"
          } else {
            Write-Warning "[Jest-JUnit] junit.xml was NOT generated at expected path: $junitFile"
          }

          $coberturaFile = Join-Path $frontendRoot "coverage\cobertura-coverage.xml"
          if (Test-Path $coberturaFile) {
            $sizeCov = (Get-Item $coberturaFile).Length
            Write-Host "[Coverage] Cobertura report found at: $coberturaFile (size: $sizeCov bytes)"
          } else {
            Write-Warning "[Coverage] Cobertura coverage file was NOT generated at $coberturaFile"
          }

    - task: PublishTestResults@2
      displayName: 'Publish Frontend Test Results (JUnit)'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(frontendPath)/test-results/junit.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)'
        testRunTitle: 'Frontend Tests'
        failTaskOnFailedTests: true

    - task: PowerShell@2
      displayName: 'Normalize Frontend Cobertura paths (avoid spaces issues)'
      condition: succeededOrFailed()
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'
          $file = "$(frontendPath)\coverage\cobertura-coverage.xml"
          if (Test-Path $file) {
            try {
              [xml]$xml = Get-Content -Raw -Path $file
            } catch {
              Write-Host "Cobertura XML not well-formed, using raw replace fallback"; $xml = $null
            }

            if ($xml -ne $null -and $xml.coverage) {
              # 1) Normalize <sources><source> => '.'
              if ($xml.coverage.sources -and $xml.coverage.sources.source) {
                foreach ($src in @($xml.coverage.sources.source)) {
                  if ($src.'#text' -ne $null) {
                    $src.'#text' = "."
                  } elseif ($src.InnerText -ne $null) {
                    # Algunos formatos exponen sólo InnerText
                    $src.InnerText = "."
                  } else {
                    Write-Host "[Cobertura] <source> node without text to normalize, skipping"
                  }
                }
              }

              # 2) Normalize class filename attributes to be relative and POSIX separators
              $prefixes = @(
                "$(Build.SourcesDirectory)\",
                "$(Build.SourcesDirectory)/",
                "$(System.DefaultWorkingDirectory)\",
                "$(System.DefaultWorkingDirectory)/"
              )

              $classes = @()
              if ($xml.coverage.packages) {
                foreach ($pkg in @($xml.coverage.packages.package)) {
                  if ($pkg.classes -and $pkg.classes.class) { $classes += @($pkg.classes.class) }
                }
              }
              foreach ($cls in $classes) {
                if (-not $cls.filename) { continue }
                $fn = [string]$cls.filename
                foreach ($p in $prefixes) { if ($fn -like "*${p}*") { $fn = $fn -replace [Regex]::Escape($p), '' } }
                $fn = $fn -replace '\\','/'
                if ($fn.StartsWith('/')) { $fn = $fn.TrimStart('/') }
                $cls.filename = $fn
              }

              $xml.Save($file)
            } else {
              # Fallback: raw string replace for both backslash and forward-slash variants
              $content = Get-Content -Raw -Path $file
              foreach ($root in @("$(Build.SourcesDirectory)", "$(System.DefaultWorkingDirectory)")) {
                $content = $content -replace [Regex]::Escape($root), "."
                $content = $content -replace [Regex]::Escape(($root -replace '\\','/')), "."
              }
              $content = $content -replace '\\','/'
              Set-Content -Path $file -Value $content -NoNewline
            }
          } else {
            Write-Host "Cobertura file not found: $file (skip normalization)"
          }

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Frontend Coverage (Cobertura)'
      condition: succeededOrFailed()
      continueOnError: true
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(frontendPath)/coverage/cobertura-coverage.xml'
        reportDirectory: '$(frontendPath)/coverage'
        failIfCoverageEmpty: false

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend Coverage'
      condition: succeededOrFailed()
      inputs:
        PathtoPublish: '$(frontendPath)/coverage'
        ArtifactName: 'frontend-coverage'
        publishLocation: 'Container'

    - script: |
        cd $(frontendPath)
        npm run build
      displayName: 'Build Frontend Application'
      env:
        NEXT_PUBLIC_API_URL: 'http://localhost:8000'
        NEXT_TELEMETRY_DISABLED: '1'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend Build (.next)'
      inputs:
        PathtoPublish: '$(frontendPath)/.next'
        ArtifactName: 'frontend-dist'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Frontend package.json'
      inputs:
        PathtoPublish: '$(frontendPath)/package.json'
        ArtifactName: 'frontend-config'
        publishLocation: 'Container'

  # =================
  # BACKEND (Go 1.22)
  # =================
  - job: BuildBackend
    displayName: 'Build Backend (Go)'
    pool: { name: $(agentPool) }
    dependsOn: BuildFrontend
    steps:
    - checkout: self
      clean: true
      displayName: 'Checkout Source Code'

    - task: GoTool@0
      displayName: 'Use Go $(goVersion)'
      inputs:
        version: '$(goVersion)'

    - script: |
        cd $(backendPath)
        go version
        echo Descargar dependencias...
        go mod download
        go mod verify
      displayName: 'Download Backend Dependencies'

    - script: |
        cd $(backendPath)
        echo Analisis estático (go vet)...
        go vet ./...
      displayName: 'Run Go Vet (Static Analysis)'
      continueOnError: true

    - task: PowerShell@2
      displayName: 'Run Backend Unit Tests (Go → JUnit + Cobertura)'
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'

          Write-Host "[Backend Tests] Working directory: $(System.DefaultWorkingDirectory)"
          Write-Host "[Backend Tests] Backend path: $(backendPath)"

          cd "$(backendPath)"

          # 1) Ejecutar tests con cobertura básica (igual que local)
          Write-Host "[Backend Tests] Running: go test ./..."
          go test ./...
          $exitCode = $LASTEXITCODE
          Write-Host "[Backend Tests] go test exit code: $exitCode"
          if ($exitCode -ne 0) {
            throw "[Backend Tests] go test ./... failed with exit code $exitCode"
          }

          # 2) Ejecutar script de cobertura del repo para generar coverage.out / coverage.html
          $scriptPath = Join-Path "$(System.DefaultWorkingDirectory)" "scripts\test_coverage.ps1"
          if (Test-Path $scriptPath) {
            Write-Host "[Backend Tests] Running coverage script: $scriptPath"
            & $scriptPath
            $covExit = $LASTEXITCODE
            Write-Host "[Backend Tests] coverage script exit code: $covExit"
            if ($covExit -ne 0) {
              throw "[Backend Tests] test_coverage.ps1 failed with exit code $covExit"
            }
          } else {
            Write-Warning "[Backend Tests] Coverage script not found at $scriptPath. Skipping coverage generation."
          }

          # 3) (Opcional) Generar JUnit + Cobertura si las herramientas están disponibles
          try {
            Write-Host "[Backend Tests] Installing go-junit-report and gocover-cobertura (optional)..."
            go install github.com/jstemmer/go-junit-report/v2@latest
            go install github.com/boumenot/gocover-cobertura@latest

            $gopath   = (go env GOPATH)
            $junitExe = Join-Path $gopath 'bin\go-junit-report.exe'
            $cobExe   = Join-Path $gopath 'bin\gocover-cobertura.exe'

            if (-not (Test-Path "$(backendPath)\test-results")) {
              New-Item -ItemType Directory -Path "$(backendPath)\test-results" | Out-Null
            }

            # JUnit: re-ejecutar tests sólo para generar reporte JUnit, sin romper pipeline si falla esta parte
            Write-Host "[Backend Tests] Generating JUnit report with go-junit-report..."
            go test ./... -v > test-output.txt
            $goTest2 = $LASTEXITCODE
            Write-Host "[Backend Tests] go test (for JUnit) exit code: $goTest2"

            if (Test-Path $junitExe) {
              type test-output.txt | & $junitExe -set-exit-code > junit-report.xml
              $junitExit = $LASTEXITCODE
              Write-Host "[Backend Tests] go-junit-report exit code: $junitExit"
            } else {
              Write-Warning "[Backend Tests] go-junit-report.exe not found at $junitExe. Skipping JUnit generation."
            }

            # Cobertura XML desde coverage.out generado por el script de cobertura
            if (Test-Path 'coverage.out' -and (Test-Path $cobExe)) {
              Write-Host "[Backend Tests] Generating Cobertura XML from coverage.out..."
              & $cobExe -i coverage.out -o coverage.cobertura.xml
              $cobExit = $LASTEXITCODE
              Write-Host "[Backend Tests] gocover-cobertura exit code: $cobExit"
            } else {
              Write-Warning "[Backend Tests] coverage.out or gocover-cobertura.exe not found. Skipping Cobertura XML."
            }
          } catch {
            Write-Warning "[Backend Tests] Optional JUnit/Cobertura generation failed: $($_.Exception.Message)"
          }

    - task: PublishTestResults@2
      displayName: 'Publish Backend Test Results (JUnit)'
      condition: succeededOrFailed()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(backendPath)/junit-report.xml'
        searchFolder: '$(System.DefaultWorkingDirectory)'
        testRunTitle: 'Backend Tests'
        failTaskOnFailedTests: true

    - task: PowerShell@2
      displayName: 'Normalize Backend Cobertura paths (avoid spaces issues)'
      condition: succeededOrFailed()
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Stop'
          $file = "$(backendPath)\coverage.cobertura.xml"
          if (Test-Path $file) {
            try {
              [xml]$xml = Get-Content -Raw -Path $file
            } catch { Write-Host "Cobertura XML not well-formed, using raw replace fallback"; $xml = $null }

            if ($xml -ne $null -and $xml.coverage) {
              if ($xml.coverage.sources -and $xml.coverage.sources.source) {
                foreach ($src in @($xml.coverage.sources.source)) { $src.'#text' = "." }
              }
              $prefixes = @(
                "$(Build.SourcesDirectory)\",
                "$(Build.SourcesDirectory)/",
                "$(System.DefaultWorkingDirectory)\",
                "$(System.DefaultWorkingDirectory)/"
              )
              $classes = @()
              if ($xml.coverage.packages) {
                foreach ($pkg in @($xml.coverage.packages.package)) {
                  if ($pkg.classes -and $pkg.classes.class) { $classes += @($pkg.classes.class) }
                }
              }
              foreach ($cls in $classes) {
                if (-not $cls.filename) { continue }
                $fn = [string]$cls.filename
                foreach ($p in $prefixes) { if ($fn -like "*${p}*") { $fn = $fn -replace [Regex]::Escape($p), '' } }
                $fn = $fn -replace '\\','/'
                if ($fn.StartsWith('/')) { $fn = $fn.TrimStart('/') }
                $cls.filename = $fn
              }
              $xml.Save($file)
            } else {
              $content = Get-Content -Raw -Path $file
              foreach ($root in @("$(Build.SourcesDirectory)", "$(System.DefaultWorkingDirectory)")) {
                $content = $content -replace [Regex]::Escape($root), "."
                $content = $content -replace [Regex]::Escape(($root -replace '\\','/')), "."
              }
              $content = $content -replace '\\','/'
              Set-Content -Path $file -Value $content -NoNewline
            }
          } else {
            Write-Host "Cobertura file not found: $file"
          }

    - task: PublishCodeCoverageResults@2
      displayName: 'Publish Backend Coverage (Cobertura)'
      condition: succeededOrFailed()
      continueOnError: true
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(backendPath)/coverage.cobertura.xml'
        reportDirectory: '$(backendPath)'
        failIfCoverageEmpty: false

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend Coverage'
      condition: succeededOrFailed()
      inputs:
        PathtoPublish: '$(backendPath)/coverage.out'
        ArtifactName: 'backend-coverage'
        publishLocation: 'Container'

    - script: |
        cd $(backendPath)
        echo Formato (go fmt)...
        go fmt ./...
      displayName: 'Check Go Formatting'
      continueOnError: true

    # Build nativo en Windows → genera bin\app.exe
    - script: |
        cd $(backendPath)
        if not exist bin mkdir bin
        echo Compilando backend...
        go build -ldflags="-w -s" -o .\bin\app.exe .\main.go
        dir .\bin
      displayName: 'Build Backend Binary (Windows)'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend Binary'
      inputs:
        PathtoPublish: '$(backendPath)/bin'
        ArtifactName: 'backend-bin'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Backend go.mod'
      inputs:
        PathtoPublish: '$(backendPath)/go.mod'
        ArtifactName: 'backend-config'
        publishLocation: 'Container'

  # ============================
  # Resumen (opcional)
  # ============================
  - job: PublishSummary
    displayName: 'Build Summary'
    pool: { name: $(agentPool) }
    dependsOn:
      - BuildFrontend
      - BuildBackend
    steps:
    - script: |
        echo ======================================
        echo    CI BUILD COMPLETED SUCCESSFULLY
        echo ======================================
        echo Build Version: $(buildVersion)
        echo Frontend: Next.js build completed
        echo Backend: Go binary compiled
        echo Artifacts:
        echo  - frontend-dist (.next)
        echo  - frontend-config (package.json)
        echo  - backend-bin (app.exe)
        echo  - backend-config (go.mod)
      displayName: 'Display Build Summary'

# ======================================================
# TP08: Build & Push backend/front → ACR
# TP05: Deploy QA → aprobación → Deploy PROD (Web Apps Linux containers)
# ======================================================

- stage: BuildAndPushImages
  displayName: 'TP08: Build & Push Backend to ACR'
  dependsOn: CI
  condition: succeeded()
  jobs:
  - job: BuildPush
    displayName: 'Docker build/push (backend + frontend)'
    pool: { name: $(agentPool) }
    steps:
      - checkout: self
        clean: true

      - task: Docker@2
        displayName: 'Login to ACR'
        inputs:
          command: 'login'
          containerRegistry: '$(dockerRegistryServiceConnection)'

      - task: Docker@2
        displayName: 'Build & Push Backend'
        inputs:
          command: 'buildAndPush'
          repository: '$(backendImageName)'          # <- repo limpio en ACR: is3-backend
          Dockerfile: '$(backendPath)/Dockerfile'
          buildContext: '$(backendPath)'
          tags: |
            $(imageTag)

      - task: Docker@2
        displayName: 'Build & Push Frontend'
        inputs:
          command: 'buildAndPush'
          repository: '$(frontendImageName)'         # <- repo limpio en ACR: is3-frontend
          Dockerfile: '$(frontendPath)/Dockerfile'
          buildContext: '$(frontendPath)'
          tags: |
            $(imageTag)

- stage: Deploy_QA
  displayName: 'TP05: Deploy Backend to QA'
  dependsOn: BuildAndPushImages
  condition: succeeded()
  jobs:
  - deployment: DeployBackendQA
    displayName: 'Deploy Backend (QA)'
    pool: { name: $(agentPool) }
    environment: 'QA'   # Environment QA en Azure DevOps (sin aprobación)
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureCLI@2
              displayName: 'Deploy Backend QA (container via Azure CLI)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                scriptType: 'ps'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  az webapp config container set `
                    --name $(backendAppQA) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --container-image-name $(acrLoginServer)/$(backendImageName):$(imageTag) `
                    --container-registry-url https://$(acrLoginServer) `
                    --container-registry-user $(acrUser) `
                    --container-registry-password $(acrPassword)

                  az webapp config appsettings set `
                    --name $(backendAppQA) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --settings `
                      "PORT=8000" `
                      "WEBSITES_PORT=8000" `
                      "ENV=qa" `
                      "DATABASE_URL=$(DATABASE_URL_QA)"

            - task: PowerShell@2
              displayName: 'Health Check QA (/health)'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = 'Stop'

                  $url = "$(backendUrlQA)/health"
                  Write-Host "Health check URL: $url"

                  $maxAttempts = 6
                  $delaySeconds = 15

                  for ($i = 1; $i -le $maxAttempts; $i++) {
                    Write-Host "Intento $i de $maxAttempts - esperando $delaySeconds segundos antes de llamar a /health..."
                    Start-Sleep -Seconds $delaySeconds

                    try {
                      $resp = Invoke-WebRequest -Uri $url -UseBasicParsing
                      Write-Host "Respuesta: $($resp.StatusCode)"
                      if ($resp.StatusCode -eq 200) {
                        Write-Host "Health check OK"
                        return
                      } else {
                        Write-Host "Health check devolvió $($resp.StatusCode), reintentando..."
                      }
                    } catch {
                      Write-Host ("Error en intento {0}: {1}" -f $i, $_.Exception.Message)
                    }
                  }

                  throw "Health check FAILED después de $maxAttempts intentos contra $url"

  - deployment: DeployFrontendQA
    displayName: 'Deploy Frontend (QA)'
    pool: { name: $(agentPool) }
    dependsOn: DeployBackendQA
    condition: and(succeeded(), ne(variables['frontendAppQA'], ''))
    environment: 'QA'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureCLI@2
              displayName: 'Deploy Frontend QA (container via Azure CLI)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                scriptType: 'ps'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  az webapp config container set `
                    --name $(frontendAppQA) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --container-image-name $(acrLoginServer)/$(frontendImageName):$(imageTag) `
                    --container-registry-url https://$(acrLoginServer) `
                    --container-registry-user $(acrUser) `
                    --container-registry-password $(acrPassword)

                  az webapp config appsettings set `
                    --name $(frontendAppQA) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --settings `
                      "PORT=3000" `
                      "WEBSITES_PORT=3000" `
                      "NEXT_PUBLIC_API_URL=https://$(backendAppQA).azurewebsites.net"

- stage: Deploy_PROD
  displayName: 'TP05: Deploy Backend to PROD (Approval)'
  dependsOn: Deploy_QA
  condition: succeeded()
  jobs:
  - deployment: DeployBackendProd
    displayName: 'Deploy Backend (PROD)'
    pool: { name: $(agentPool) }
    environment: 'PROD'  # Configurar aprobación manual en Environment PROD
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureCLI@2
              displayName: 'Deploy Backend PROD (container via Azure CLI)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                scriptType: 'ps'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  az webapp config container set `
                    --name $(backendAppProd) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --container-image-name $(acrLoginServer)/$(backendImageName):$(imageTag) `
                    --container-registry-url https://$(acrLoginServer) `
                    --container-registry-user $(acrUser) `
                    --container-registry-password $(acrPassword)

                  az webapp config appsettings set `
                    --name $(backendAppProd) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --settings `
                      "PORT=8000" `
                      "WEBSITES_PORT=8000" `
                      "ENV=production" `
                      "DATABASE_URL=$(DATABASE_URL_PROD)"

            - task: PowerShell@2
              displayName: 'Health Check PROD (/health)'
              inputs:
                targetType: 'inline'
                script: |
                  $ErrorActionPreference = 'Stop'
                  Write-Host "Esperando 20s a que arranque..."; Start-Sleep -Seconds 20
                  $resp = Invoke-WebRequest -Uri "$(backendUrlProd)/health" -UseBasicParsing
                  if ($resp.StatusCode -ne 200) { throw "Health check FAILED: $($resp.StatusCode)" }

  - deployment: DeployFrontendProd
    displayName: 'Deploy Frontend (PROD)'
    pool: { name: $(agentPool) }
    dependsOn: DeployBackendProd
    condition: and(succeeded(), ne(variables['frontendAppProd'], ''))
    environment: 'PROD'
    strategy:
      runOnce:
        deploy:
          steps:
            - task: AzureCLI@2
              displayName: 'Deploy Frontend PROD (container via Azure CLI)'
              inputs:
                azureSubscription: '$(azureSubscription)'
                scriptType: 'ps'
                scriptLocation: 'inlineScript'
                inlineScript: |
                  az webapp config container set `
                    --name $(frontendAppProd) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --container-image-name $(acrLoginServer)/$(frontendImageName):$(imageTag) `
                    --container-registry-url https://$(acrLoginServer) `
                    --container-registry-user $(acrUser) `
                    --container-registry-password $(acrPassword)

                  az webapp config appsettings set `
                    --name $(frontendAppProd) `
                    --resource-group rg-tp05-ingsoft3-2025 `
                    --settings `
                      "PORT=3000" `
                      "WEBSITES_PORT=3000" `
                      "NEXT_PUBLIC_API_URL=https://$(backendAppProd).azurewebsites.net"
